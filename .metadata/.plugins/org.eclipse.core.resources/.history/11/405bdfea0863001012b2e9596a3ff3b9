
/*
 * cmd.c
 *
 *  Created on: Jun 30, 2025
 *      Author: nicks
 */

#include "main.h"
#include "cmd.h"
#include "cmsis_os.h"
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <ctype.h>
#include "trilateration.h"

uint32_t last_anchor_print = 0;

/* ===== receive buffers ===== */
uint8_t rx_from_pc;
uint8_t rx_from_bu01;
uint8_t rx_from_hc05;

/* ===== input line buffer (for PC commands) ===== */
#define MAX_INPUT  32
static char    input_buf[MAX_INPUT];
static uint8_t input_pos = 0;

/* ===== circular buffer for BU-01 RX ===== */
#define BU01_BUF_SIZE 256
uint8_t  bu01_rx_buffer[BU01_BUF_SIZE];
volatile uint16_t bu01_rx_write_idx = 0;
volatile uint16_t bu01_rx_read_idx  = 0;

/* ===== line buffer for printing BU-01 responses ===== */
char     line_buf[64];
uint8_t  line_pos = 0;
int anchordistance[3] = {0};  // in millimeters

/* ===== HC05 circular buffer ===== */
uint8_t  hc05_rx_buffer[HC05_BUF_SIZE];
volatile uint16_t hc05_rx_write_idx = 0;
volatile uint16_t hc05_rx_read_idx  = 0;
char hc05_line_buf[64];
uint8_t hc05_line_pos = 0;

/* ===== BU-01 AT commands ===== */
static const char *bu01_commands[] = {
    "AT\r\n",               // 0
    "AT+version?\r\n",      // 1
    "AT+anchor_tag=0\r\n",  // 2
    "AT+anchor_tag=1\r\n",  // 3
    "AT+switchdis=1\r\n",   // 4
    "AT+interval=5\r\n",    // 5
    "AT+RST\r\n",           // 6
    "AT+tem_hum\r\n",       // 7
    "AT+xyz\r\n",           // 8
    "AT+FACTORY\r\n",       // 9
    "AT+anchor_tag?\r\n",   // 10
    "AT+switchdis=0\r\n"    // 11
};
#define NUM_BU01_CMDS  (sizeof(bu01_commands)/sizeof(bu01_commands[0]))

/* ===== HC-05 AT commands ===== */
static const char *hc05_commands[] = {
    "AT\r\n",               // 0
    "AT+ROLE?\r\n",         // 1
    "AT+ADDR?\r\n",         // 2
    "AT+NAME?\r\n",         // 3
    "AT+PSWD?\r\n",         // 4
    "AT+ROLE=1\r\n",         // 5
    "AT+CMODE=0\r\n",         // 6
    "AT+BIND=0014030559BE\r\n",         // 7
    "AT+LINK=0014030559BE\r\n",         // 8
	"AT+RESET\r\n",			// 9
	"AT+INIT\r\n",			// 10
	"AT+INQM=1,9,48\r\n",	// 11
	"AT+INQ\r\n",			// 12
	"AT+VERSION?\r\n",		// 13
	"AT+CMODE=1\r\n",         // 14
	"AT+switchdis=1\r\n",   // 15
	"AT+RST\r\n",			// 16
	"AT+interval=5\r\n",    // 17
	"AT+interval=10\r\n",    // 18
    // add more HC-05 commands as needed…
};
#define NUM_HC05_CMDS  (sizeof(hc05_commands)/sizeof(hc05_commands[0]))

/* ===== STM32 command table ===== */
typedef void (*CmdFunc_t)(int argc, char *argv[]);

typedef struct {
    CmdFunc_t   func;    // handler
    const char *cmd;     // name
    const char *args;    // arg list
    const char *help;    // description
} CMD_T;

static void _cmd_reset(int argc, char *argv[]);

static const CMD_T stm32_cmds[] = {
    { _cmd_reset, "reset", "", "Restart the STM32" },
};

static const size_t stm32_cmd_count =
    sizeof(stm32_cmds) / sizeof(stm32_cmds[0]);

/* ===== OS thread definitions ===== */
void          cmdlinego(void *argument);
osThreadId_t  cmdlineID;
const osThreadAttr_t cmdline_att = {
  .name       = "cmdline",
  .stack_size = 2048,
  .priority   = (osPriority_t) osPriorityNormal,
};

/* ===== function prototypes ===== */
void uartt_init(void);

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);

/* ---------------------------------------------------------------------- */
/* STM32 command handlers                                                 */
/* ---------------------------------------------------------------------- */
static void _cmd_reset(int argc, char *argv[])
{
    (void)argc; (void)argv;
    /* flush any pending TX */
    while (__HAL_UART_GET_FLAG(&huart2, UART_FLAG_TC) == RESET) { }
    HAL_UART_Transmit(&huart2, (uint8_t *)"STM32 resetting...\r\n", 20, HAL_MAX_DELAY);
    HAL_NVIC_SystemReset();
}

/* ---------------------------------------------------------------------- */
/* background task: forward BU-01 data to PC over UART2                   */
/* ---------------------------------------------------------------------- */
void cmdlinego(void *argument)
{
    (void)argument;
    for (;;)
    {
        // === BU-01 direct parsing ===
    	if (bu01_rx_read_idx != bu01_rx_write_idx)
		{
			char c = bu01_rx_buffer[bu01_rx_read_idx++];
			if (bu01_rx_read_idx >= BU01_BUF_SIZE)
				bu01_rx_read_idx = 0;

			line_buf[line_pos++] = c;
			if (c == '\n' || line_pos >= sizeof(line_buf) - 1)
			{
				line_buf[line_pos] = '\0';
				HAL_UART_Transmit(&huart2, (uint8_t *)line_buf, line_pos, HAL_MAX_DELAY);
				line_pos = 0;
			}
		}

        // === HC-05 Bluetooth parsing ===
        if (hc05_rx_read_idx != hc05_rx_write_idx)
        {

            char c = hc05_rx_buffer[hc05_rx_read_idx++];
            if (hc05_rx_read_idx >= HC05_BUF_SIZE)
                hc05_rx_read_idx = 0;

            if (hc05_line_pos < sizeof(hc05_line_buf) - 1)
                hc05_line_buf[hc05_line_pos++] = c;

            if (c == '\n' || hc05_line_pos >= sizeof(hc05_line_buf) - 1)
            {
                hc05_line_buf[hc05_line_pos] = '\0';

                if (strncmp(hc05_line_buf, "an0:", 4) == 0)
                    anchordistance[0] = (uint16_t)(strtof(&hc05_line_buf[4], NULL) * 1000);
                else if (strncmp(hc05_line_buf, "an2:", 4) == 0)
                    anchordistance[1] = (uint16_t)(strtof(&hc05_line_buf[4], NULL) * 1000);
                else if (strncmp(hc05_line_buf, "an3:", 4) == 0)
                {
                    anchordistance[2] = (uint16_t)(strtof(&hc05_line_buf[4], NULL) * 1000);
                    //uint32_t now = HAL_GetTick();  // current time in ms						// MIGHT NOT NEED TO TIME THIS
					//if (now - last_anchor_print >= 500)
					{

						//last_anchor_print = now;
					//printf("an0=%d mm, an2=%d mm, an3=%d mm\n", anchordistance[0], anchordistance[1], anchordistance[2]);
					if(GetLocation(&tag_position, 0, &(AnchorList[0]), &(anchordistance[0])) != -1)
					{
					printf("Tag Location:x=%3.2fm y=%3.2fm z=%3.2fm\r\n",tag_position.x,tag_position.y,tag_position.z);
					//sprintf(dist_str, "x:%3.2f y:%3.2f",tag_best_solution.x,tag_best_solution.y);
					}
					}
                }
                if (strncmp(hc05_line_buf, "an", 2) != 0)
                	printf("%s\n",hc05_line_buf);

                hc05_line_pos = 0;
            }
        }

        osDelay(1);
    }
}

/* ---------------------------------------------------------------------- */
/* initialize UART interrupts for PC (UART2), BU-01 (UART1), HC-05(UART3)*/
/* ---------------------------------------------------------------------- */
void uartt_init(void)
{
    //HAL_UART_Receive_IT(&huart1, &rx_from_bu01, 1);
    HAL_UART_Receive_IT(&huart2, &rx_from_pc,   1);
    //HAL_UART_Receive_IT(&huart3, &rx_from_hc05,  1);
}

/* ---------------------------------------------------------------------- */
/* start the command-line thread                                          */
/* ---------------------------------------------------------------------- */
void cmd_line_init(void)
{
    cmdlineID = osThreadNew(cmdlinego, NULL, &cmdline_att);
}

/* ---------------------------------------------------------------------- */
/* interrupt callback for all UARTs                                       */
/*   - UART2: commands from PC                                             */
/*   - UART1: responses from BU-01                                         */
/*   - UART3: responses from HC-05                                         */
/* ---------------------------------------------------------------------- */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    /* --- PC input (UART2) --- */
    if (huart == &huart2)
    {
        char c = rx_from_pc;

        /* echo back */
        //HAL_UART_Transmit(&huart2, &c, 1, HAL_MAX_DELAY);

        /* on newline, dispatch */
        if (c == '\r' || c == '\n')
        {
            input_buf[input_pos] = '\0';

            if (input_pos > 0)
            {

                // BU-01 if leading digit
                if (isdigit((unsigned char)input_buf[0]))
                {
                	/*
                    int idx = atoi(input_buf);
                    if (idx >= 0 && idx < NUM_BU01_CMDS)
                    {
                        HAL_UART_Transmit(&huart1,
                                          (uint8_t*)bu01_commands[idx],
                                          strlen(bu01_commands[idx]),
                                          HAL_MAX_DELAY);
                        HAL_UART_Transmit(&huart2,
                                          (uint8_t*)bu01_commands[idx],
                                          strlen(bu01_commands[idx]),
                                          HAL_MAX_DELAY);
                    }
                    else
                    {
                        HAL_UART_Transmit(&huart2,
                                          (uint8_t *)"Invalid BU-01 index\r\n",
                                          19,
                                          HAL_MAX_DELAY);
                    }*/
                }

                /* HC-05 if ‘H’ or ‘h’ + digit */
                else if ((input_buf[0] == 'H' || input_buf[0] == 'h')
                         && isdigit((unsigned char)input_buf[1]))
                {
                    int idx = atoi(&input_buf[1]);
                    if (idx >= 0 && idx < NUM_HC05_CMDS)
                    {
                        HAL_UART_Transmit(&huart3,
                                          (uint8_t*)hc05_commands[idx],
                                          strlen(hc05_commands[idx]),
                                          HAL_MAX_DELAY);
                        HAL_UART_Transmit(&huart2,
                                          (uint8_t*)hc05_commands[idx],
                                          strlen(hc05_commands[idx]),
                                          HAL_MAX_DELAY);
                    }
                    else
                    {
                        HAL_UART_Transmit(&huart2,
                                          (uint8_t *)"Invalid HC-05 index\r\n",
                                          20,
                                          HAL_MAX_DELAY);
                    }
                }
                /* otherwise STM32 commands */
                else
                {
                    char *argv[8];
                    int   argc = 0;
                    char *tok = strtok(input_buf, " ");
                    while (tok && argc < (int)(sizeof(argv)/sizeof(argv[0])))
                    {
                        argv[argc++] = tok;
                        tok = strtok(NULL, " ");
                    }

                    bool matched = false;
                    for (size_t i = 0; i < stm32_cmd_count; ++i)
                    {
                        if (strcmp(argv[0], stm32_cmds[i].cmd) == 0)
                        {
                            stm32_cmds[i].func(argc, argv);
                            matched = true;
                            break;
                        }
                    }
                    if (!matched)
                    {
                        HAL_UART_Transmit(&huart2,
                                          (uint8_t *)"Unknown command\r\n",
                                          17,
                                          HAL_MAX_DELAY);
                    }
                }
            }

            /* reset buffer */
            input_pos = 0;
        }
        /* accumulate valid characters */
        else if (input_pos < (MAX_INPUT - 1) &&
                 (isalnum((unsigned char)c) || c == '_'))
        {
            input_buf[input_pos++] = c;
        }
        else
        {
            /* overflow or invalid => reset */
            input_pos = 0;
        }

        /* re-arm PC receive */
        HAL_UART_Receive_IT(&huart2, &rx_from_pc, 1);
    }
    /* --- BU-01 input (UART1) --- */
    /*
    else if (huart == &huart1)
    {
        bu01_rx_buffer[bu01_rx_write_idx++] = rx_from_bu01;
        if (bu01_rx_write_idx >= BU01_BUF_SIZE)
            bu01_rx_write_idx = 0;
        HAL_UART_Receive_IT(&huart1, &rx_from_bu01, 1);
    } */
    /* --- HC-05 input (UART3) --- */
    else if (huart == &huart3)
    {
        hc05_rx_buffer[hc05_rx_write_idx++] = rx_from_hc05;
        if (hc05_rx_write_idx >= HC05_BUF_SIZE)
            hc05_rx_write_idx = 0;

        // Optional: still forward to PC for debug
        //HAL_UART_Transmit(&huart2, &rx_from_hc05, 1, HAL_MAX_DELAY);

        HAL_UART_Receive_IT(&huart3, &rx_from_hc05, 1);
    }
}
